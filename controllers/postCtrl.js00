const Posts = require('../models/postModel')
const Comments = require('../models/commentModel')
const Users = require('../models/userModel')
const cloudinary = require('cloudinary').v2;

// Configurar Cloudinary
cloudinary.config({
    cloud_name: 'dfjipgj2o',
    api_key: '213981915435275',
    api_secret: 'wv_IiCM9zzhdiWDNXXo8HZi7wX4'
});
class APIfeatures {
    constructor(query, queryString){
        this.query = query;
        this.queryString = queryString;
    }

    paginating(){
        const page = this.queryString.page * 1 || 1
        const limit = this.queryString.limit * 1 || 9
        const skip = (page - 1) * limit
        this.query = this.query.skip(skip).limit(limit)
        return this;
    }
}

const postCtrl = {
 // üìÑ controllers/postController.js - createPost
createPost: async (req, res) => {
    try {
      const { postData, images } = req.body;
      
      if (!images || images.length === 0) {
        return res.status(400).json({msg: "Veuillez ajouter au moins une photo."})
    }

    if (!postData.subCategory) {
        return res.status(400).json({msg: "La sous-cat√©gorie est requise."})
    }
      
      const commonFields = [
        'categorie', 'subCategory', 'articleType',
       
      ];
      
      const commonData = {};
      const specificData = {};
      
      Object.keys(postData).forEach(key => {
        if (commonFields.includes(key)) {
          commonData[key] = postData[key];
        } else {
          specificData[key] = postData[key];
        }
      });
      
      // ‚úÖ CREAR POST CON ESTRUCTURA CORRECTA
      const newPost = new Posts({
        ...commonData,
        categorySpecificData: specificData, // ‚Üê ¬°Nombre consistente!
        images: images,
        user: req.user._id,
        likes: [],
      });
      
      await newPost.save();
      
      res.json({
        msg: 'Post cr√©√© avec succ√®s!',
        newPost
      });
    } catch (err) {
        console.error('Error en creePost:', err);
        return res.status(500).json({msg: err.message});
    }
  },
   
    
    // üìÑ ACTUALIZAR POST
    updatePost: async (req, res) => {
        try {
            const { postData, images } = req.body;
            
            // 1. Obtener el post actual
            const oldPost = await Posts.findById(req.params.id);
            if (!oldPost) {
                return res.status(400).json({msg: "Ce post n'existe pas."});
            }
            
            // 2. Verificar permisos (solo el due√±o puede editar)
            if (oldPost.user.toString() !== req.user._id.toString()) {
                return res.status(400).json({msg: "Vous n'avez pas l'autorisation."});
            }
            
            // 3. Determinar tipo de post
            const isBoutique = oldPost.postType === 'boutique';
            
            // 4. Separar campos
            const commonFields = [
                'categorie', 'subCategory', 'articleType',
                'operationType', 'propertyType', 'postType',
                'price', 'description', 'etat', 'title'
            ];
            
            const locationFields = ['wilaya', 'commune', 'address'];
            
            const updateData = {};
            const specificData = {};
            const locationData = {};
            
            Object.keys(postData).forEach(key => {
                if (commonFields.includes(key)) {
                    updateData[key] = postData[key];
                } else if (locationFields.includes(key)) {
                    locationData[key] = postData[key];
                } else {
                    specificData[key] = postData[key];
                }
            });
            
            // 5. Agregar categorySpecificData
            if (Object.keys(specificData).length > 0) {
                updateData.categorySpecificData = specificData;
            }
            
            // 6. Agregar ubicaci√≥n
            if (Object.keys(locationData).length > 0) {
                updateData.location = locationData;
            }
            
            // 7. Agregar im√°genes
            if (images && images.length > 0) {
                updateData.images = images;
            }
            
            // 8. üî• MANEJAR DATOS DE BOUTIQUE SI ES NECESARIO
            if (isBoutique) {
                const boutiqueUpdate = {};
                const boutiqueFields = [
                    'nom_boutique', 'domaine_boutique', 'slogan_boutique',
                    'description_boutique', 'categories_produits', 'couleur_theme',
                    'plan_boutique', 'duree_abonnement', 'total_credits',
                    'stockage_max', 'inclusions_plan', 'proprietaire_nom',
                    'proprietaire_email', 'proprietaire_telephone', 'proprietaire_wilaya',
                    'proprietaire_adresse', 'reseau_sociaux', 'logo_boutique'
                ];
                
                // Extraer campos de boutique de postData
                boutiqueFields.forEach(field => {
                    if (postData[field] !== undefined) {
                        boutiqueUpdate[field] = postData[field];
                    }
                });
                
                // Agregar boutiqueData al update si hay campos
                if (Object.keys(boutiqueUpdate).length > 0) {
                    updateData.boutiqueData = {
                        ...oldPost.boutiqueData,
                        ...boutiqueUpdate
                    };
                }
            } else {
                // Para productos normales, asegurar que boutiqueData sea null
                updateData.boutiqueData = null;
            }
            
            // 9. Actualizar post
            const post = await Posts.findOneAndUpdate(
                { _id: req.params.id },
                { $set: updateData },
                { 
                    new: true, 
                    runValidators: true,
                    context: 'query' // Importante para validaciones
                }
            ).populate('user', 'avatar username');
            
            res.json({
                msg: isBoutique ? 'Boutique modifi√©e avec succ√®s!' : 'Post modifi√© avec succ√®s!',
                newPost: post
            });
            
        } catch (err) {
            console.error('Error en updatePost:', err);
            
            // Manejar errores de validaci√≥n
            if (err.name === 'ValidationError') {
                const errors = Object.values(err.errors).map(e => e.message);
                return res.status(400).json({msg: errors.join(', ')});
            }
            
            // Manejar error de duplicado
            if (err.code === 11000) {
                return res.status(400).json({msg: "Ce domaine de boutique est d√©j√† utilis√©."});
            }
            
            return res.status(500).json({msg: err.message});
        }
    },
    
    // üìÑ OBTENER POSTS CON FILTROS
    getPosts: async (req, res) => {
        try {
            const features = new APIfeatures(
                Posts.find({ isActive: true })
                    .populate('user', 'avatar username fullname')
                    .sort({ createdAt: -1 }),
                req.query
            ).paginating();
            
            const posts = await features.query;
            
            res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            });
            
        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },
    
    // üìÑ OBTENER POSTS POR CATEGOR√çA
    getPostsByCategory: async (req, res) => {
        try {
            const { categorie, subCategory } = req.params;
            const { page = 1, limit = 12 } = req.query;
            const skip = (page - 1) * limit;
            
            // Construir filtro
            const filter = { 
                isActive: true,
                categorie: categorie 
            };
            
            if (subCategory && subCategory !== 'all') {
                filter.subCategory = subCategory;
            }
            
            // Obtener posts
            const posts = await Posts.find(filter)
                .populate('user', 'avatar username fullname')
                .sort({ createdAt: -1 })
                .skip(skip)
                .limit(parseInt(limit));
            
            // Contar total
            const total = await Posts.countDocuments(filter);
            
            res.json({
                msg: 'Success!',
                result: posts.length,
                total,
                totalPages: Math.ceil(total / limit),
                currentPage: parseInt(page),
                posts
            });
            
        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },
    
    // üìÑ OBTENER POST POR ID
    getPost: async (req, res) => {
        try {
            const post = await Posts.findById(req.params.id)
                .populate('user', 'avatar username fullname email phone')
                .populate('likes', 'avatar username');
            
            if (!post) {
                return res.status(400).json({msg: "Ce post n'existe pas."});
            }
            
            // Incrementar vistas
            post.views += 1;
            await post.save();
            
            // Obtener posts similares
            const similarPosts = await Posts.find({
                _id: { $ne: post._id },
                categorie: post.categorie,
                subCategory: post.subCategory,
                isActive: true
            })
            .limit(4)
            .populate('user', 'avatar username');
            
            res.json({
                msg: 'Success!',
                post,
                similarPosts
            });
            
        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },
    
    // üìÑ OBTENER POSTS DEL USUARIO
    getUserPosts: async (req, res) => {
        try {
            const features = new APIfeatures(
                Posts.find({ 
                    user: req.user._id,
                    isActive: true 
                })
                .populate('user', 'avatar username')
                .sort({ createdAt: -1 }),
                req.query
            ).paginating();
            
            const posts = await features.query;
            
            res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            });
            
        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },
    
    // üìÑ OBTENER BOUTIQUES
    getBoutiques: async (req, res) => {
        try {
            const { status, page = 1, limit = 10 } = req.query;

            const query = { postType: 'boutique' };

            // Filtrar por status si se especifica
            if (status && ['pending', 'active', 'suspended', 'expired'].includes(status)) {
                query['boutiqueData.boutique_status'] = status;
            }

            const features = new APIfeatures(
                Posts.find(query).populate('user', 'avatar username email'),
                req.query
            ).paginating();

            const boutiques = await features.query;
            const total = await Posts.countDocuments(query);

            res.json({
                success: true,
                boutiques,
                total,
                currentPage: parseInt(page),
                totalPages: Math.ceil(total / limit)
            });

        } catch (err) {
            console.error('‚ùå Error en getBoutiques:', err);
            return res.status(500).json({ success: false, msg: err.message });
        }
    },

    // ‚úÖ M√âTODO ADICIONAL: Activar boutique
    activateBoutique: async (req, res) => {
        try {
            const { boutiqueId } = req.params;

            const boutique = await Posts.findOne({
                _id: boutiqueId,
                postType: 'boutique'
            });

            if (!boutique) {
                return res.status(404).json({
                    success: false,
                    msg: 'Boutique non trouv√©e'
                });
            }

            // Verificar que el usuario sea admin o propietario
            if (req.user.role !== 'admin' && !boutique.user.equals(req.user._id)) {
                return res.status(403).json({
                    success: false,
                    msg: 'Acc√®s non autoris√©'
                });
            }

            // Calcular fecha de expiraci√≥n basada en la duraci√≥n
            const durationMap = {
                '1_mois': 30,
                '3_mois': 90,
                '6_mois': 180,
                '12_mois': 365
            };

            const days = durationMap[boutique.boutiqueData.duree_abonnement] || 30;
            const expirationDate = new Date();
            expirationDate.setDate(expirationDate.getDate() + days);

            // Actualizar boutique
            boutique.boutiqueData.boutique_status = 'active';
            boutique.boutiqueData.date_activation = new Date();
            boutique.boutiqueData.date_expiration = expirationDate;
            boutique.isActive = true;

            await boutique.save();

            res.json({
                success: true,
                msg: 'Boutique activ√©e avec succ√®s!',
                boutique: {
                    _id: boutique._id,
                    nom_boutique: boutique.boutiqueData.nom_boutique,
                    domaine_boutique: boutique.boutiqueData.domaine_boutique,
                    status: 'active',
                    date_activation: boutique.boutiqueData.date_activation,
                    date_expiration: boutique.boutiqueData.date_expiration
                }
            });

        } catch (err) {
            console.error('‚ùå Error en activateBoutique:', err);
            return res.status(500).json({ success: false, msg: err.message });
        }
    },


    // üìå OBTENER POSTS (corregido)
    getPosts: async (req, res) => {
        try {
            const { page = 1, limit = 9, category } = req.query;
            const skip = (page - 1) * limit;

            // Construir query
            let query = { isActive: true };

            // Si hay categor√≠a, filtrar
            if (category && category !== 'all') {
                query.categorie = category;
            }

            // Obtener posts
            const posts = await Posts.find(query)
                .skip(skip)
                .limit(parseInt(limit))
                .sort('-createdAt')
                .populate("user", "avatar username");

            // Contar total
            const total = await Posts.countDocuments(query);

            res.json({
                msg: 'Success!',
                result: posts.length,
                total,
                page: parseInt(page),
                totalPages: Math.ceil(total / limit),
                posts
            });

        } catch (err) {
            console.error('‚ùå Error en getPosts:', err);
            return res.status(500).json({ msg: err.message });
        }
    },


    getPostsByCategory: async (req, res) => {
        try {
            const { category } = req.params;
            const { page = 1, limit = 9 } = req.query;
            const skip = (page - 1) * limit;

            const query = {
                categorie: category,
                isActive: true
            };

            const [posts, total] = await Promise.all([
                Posts.find(query)
                    .skip(skip)
                    .limit(parseInt(limit))
                    .sort('-createdAt')
                    .populate("user", "avatar username"),
                Posts.countDocuments(query)
            ]);

            res.json({
                success: true,
                posts,
                total,
                page: parseInt(page),
                totalPages: Math.ceil(total / limit),
                hasMore: skip + posts.length < total
            });

        } catch (err) {
            console.error('‚ùå Error en getPostsByCategory:', err);
            return res.status(500).json({ msg: err.message });
        }
    },





    // üìå OBTENER TODAS LAS CATEGOR√çAS (nuevo)
    // backend/controllers/postCtrl.js - NUEVO CONTROLADOR
    getAllCategoriesPaginated: async (req, res) => {
        console.log('üîç === getAllCategoriesPaginated START ===');

        try {
            const { page = 1, limit = 2 } = req.query;
            const skip = (page - 1) * limit;

            console.log('üìä Par√°metros recibidos:', { page, limit, skip });

            // ========== VALIDAR MODELOS ==========
            console.log('üîç Verificando modelos...');

            // Verificar que Posts exista
            if (!Posts) {
                console.error('‚ùå CRITICAL: Posts model is undefined');
                console.error('   Verifica la importaci√≥n: const Posts = require("../models/postModel")');
                return res.status(500).json({
                    success: false,
                    msg: 'Erreur de configuration - Mod√®le Posts non trouv√©',
                    errorCode: 'POSTS_MODEL_UNDEFINED'
                });
            }

            // Verificar que Store exista (si lo usas)
            let Store;
            try {
                Store = require('../models/storeModel');
                console.log('‚úÖ Store model loaded successfully');
            } catch (storeError) {
                console.warn('‚ö†Ô∏è Store model not available:', storeError.message);
                Store = null;
            }

            // ========== OBTENER CATEGOR√çAS DE POSTS ==========
            console.log('üîç Obteniendo categor√≠as de posts...');
            const postCategories = await Posts.aggregate([
                { $match: { isActive: true } },
                {
                    $group: {
                        _id: "$categorie",
                        count: { $sum: 1 },
                        type: { $first: "post" }
                    }
                },
                { $sort: { count: -1 } }
            ]);

            console.log(`‚úÖ Post categories found: ${postCategories.length}`);

            // ========== OBTENER CATEGOR√çAS DE STORES ==========
            let storeCategories = [];
            let storeCount = 0;

            if (Store) {
                try {
                    console.log('üîç Obteniendo categor√≠as de stores...');
                    storeCategories = await Store.aggregate([
                        { $match: { isActive: true } },
                        {
                            $group: {
                                _id: "$category",
                                count: { $sum: 1 },
                                type: { $first: "store" }
                            }
                        },
                        { $sort: { count: -1 } }
                    ]);

                    storeCount = await Store.countDocuments({ isActive: true });
                    console.log(`‚úÖ Store categories found: ${storeCategories.length}`);
                    console.log(`‚úÖ Total stores: ${storeCount}`);
                } catch (storeAggError) {
                    console.warn('‚ö†Ô∏è Error al obtener stores:', storeAggError.message);
                }
            }

            // ========== COMBINAR CATEGOR√çAS ==========
            console.log('üîç Combinando categor√≠as...');

            const allCategories = [];

            // Agregar categor√≠a "stores" solo si hay tiendas
            if (storeCount > 0) {
                allCategories.push({
                    _id: 'stores',
                    name: 'stores',
                    displayName: 'Boutiques',
                    count: storeCount,
                    type: 'store_category',
                    emoji: 'üè™'
                });
            }

            // Agregar categor√≠as de posts
            postCategories.forEach(cat => {
                allCategories.push({
                    ...cat,
                    name: cat._id,
                    type: 'post'
                });
            });

            // Agregar categor√≠as de stores (para filtrado interno)
            if (storeCategories.length > 0) {
                storeCategories.forEach(cat => {
                    allCategories.push({
                        ...cat,
                        name: cat._id,
                        type: 'store_subcategory'
                    });
                });
            }

            console.log(`‚úÖ Total categories combined: ${allCategories.length}`);

            // ========== AGREGAR EMOJIS ==========
            const categoryEmojis = {
                'stores': 'üè™',
                'vehicules': 'üöó',
                'immobilier': 'üè†',
                'informatique': 'üíª',
                'vetements': 'üëï',
                'telephones': 'üì±',
                'services': 'üõ†Ô∏è',
                'electromenager': 'üîå',
                'piecesDetachees': '‚öôÔ∏è',
                'alimentaires': 'üçé',
                'santebeaute': 'üíÑ',
                'meubles': 'üõãÔ∏è',
                'materiaux': 'üß±',
                'loisirs': 'üéÆ',
                'emploi': 'üíº',
                'sport': '‚öΩ',
                'voyages': '‚úàÔ∏è'
            };

            const categoriesWithEmojis = allCategories.map(cat => ({
                id: cat._id,
                name: cat.name,
                displayName: cat.displayName || cat.name,
                count: cat.count || 0,
                emoji: categoryEmojis[cat._id] || (cat.type === 'store_category' ? 'üè™' : 'üì¶'),
                type: cat.type || 'post'
            }));

            // ========== PAGINACI√ìN ==========
            const totalCategories = categoriesWithEmojis.length;
            const paginatedCategories = categoriesWithEmojis.slice(skip, skip + parseInt(limit));

            console.log('üìä Resultado paginaci√≥n:', {
                total: totalCategories,
                page: parseInt(page),
                limit: parseInt(limit),
                returned: paginatedCategories.length,
                hasMore: skip + paginatedCategories.length < totalCategories
            });

            console.log('‚úÖ === getAllCategoriesPaginated SUCCESS ===');

            res.json({
                success: true,
                categories: paginatedCategories,
                page: parseInt(page),
                total: totalCategories,
                totalPages: Math.ceil(totalCategories / limit),
                hasMore: skip + paginatedCategories.length < totalCategories
            });

        } catch (err) {
            console.error('‚ùå === getAllCategoriesPaginated ERROR ===');
            console.error('‚ùå Error message:', err.message);
            console.error('‚ùå Error stack:', err.stack);

            // Informaci√≥n adicional para debug
            console.error('‚ùå Additional info:');
            console.error('   - Posts model:', Posts ? 'Defined' : 'Undefined');
            console.error('   - Error type:', err.name);

            // Respuesta de error m√°s informativa
            return res.status(500).json({
                success: false,
                msg: 'Erreur interne du serveur lors du chargement des cat√©gories',
                error: process.env.NODE_ENV === 'development' ? {
                    message: err.message,
                    stack: err.stack,
                    name: err.name
                } : undefined,
                timestamp: new Date().toISOString()
            });
        }
    },
    getPostsBySubcategory: async (req, res) => {
        try {
            const { category, subCategory } = req.params;
            const { page = 1, limit = 9 } = req.query;
            const skip = (page - 1) * limit;

            console.log(`üîç Buscando posts: ${category}/${subCategory}, p√°gina ${page}`);

            const query = {
                categorie: category,
                subCategory: subCategory,
                isActive: true
            };

            const [posts, total] = await Promise.all([
                Posts.find(query)
                    .skip(skip)
                    .limit(parseInt(limit))
                    .sort({ isPromoted: -1, isUrgent: -1, createdAt: -1 })
                    .populate("user", "avatar username"),
                Posts.countDocuments(query)
            ]);

            res.json({
                success: true,
                posts,
                total,
                page: parseInt(page),
                totalPages: Math.ceil(total / parseInt(limit)),
                hasMore: skip + posts.length < total
            });

        } catch (err) {
            console.error('‚ùå Error en getPostsBySubcategory:', err);
            return res.status(500).json({ msg: err.message });
        }
    },

    // üìå OBTENER SUBCATEGOR√çAS DE UNA CATEGOR√çA (NUEVO)
    getSubCategoriesByCategory: async (req, res) => {
        try {
            const { category } = req.params;

            // Buscar todas las subcategor√≠as √∫nicas para esta categor√≠a
            const subcategories = await Posts.aggregate([
                {
                    $match: {
                        categorie: category,
                        subCategory: { $exists: true, $ne: "" }
                    }
                },
                {
                    $group: {
                        _id: "$subCategory",
                        count: { $sum: 1 }
                    }
                },
                { $sort: { count: -1 } }
            ]);

            res.json({
                success: true,
                subcategories: subcategories.map(sub => ({
                    id: sub._id,
                    name: sub._id,
                    count: sub.count
                }))
            });

        } catch (err) {
            console.error('‚ùå Error en getSubCategoriesByCategory:', err);
            return res.status(500).json({ msg: err.message });
        }
    },
    // backend/controllers/postCtrl.js
    // backend/controllers/postCtrl.js
    getPostsByImmobilierOperation: async (req, res) => {
        try {
            const { operationId } = req.params;
            const { page = 1, limit = 9 } = req.query;
            const skip = (page - 1) * limit;

            console.log(`üîç Buscando posts de immobiler: operaci√≥n ${operationId}`);

            // Buscar posts con operationType = operationId
            const query = {
                categorie: 'immobilier',
                operationType: operationId, // ¬°Nuevo campo necesario!
                isActive: true
            };

            const [posts, total] = await Promise.all([
                Posts.find(query)
                    .skip(skip)
                    .limit(parseInt(limit))
                    .sort({ isPromoted: -1, isUrgent: -1, createdAt: -1 })
                    .populate("user", "avatar username"),
                Posts.countDocuments(query)
            ]);

            res.json({
                success: true,
                posts,
                total,
                page: parseInt(page),
                totalPages: Math.ceil(total / parseInt(limit)),
                hasMore: skip + posts.length < total
            });

        } catch (err) {
            console.error('‚ùå Error en getPostsByImmobilierOperation:', err);
            return res.status(500).json({ msg: err.message });
        }
    },
    getSimilarPosts: async (req, res) => {
        try {
            console.log('üì• getSimilarPosts recibi√≥:', req.query);

            const {
                categorie,
                subCategory,
                excludeId,
                limit = 6,
                page = 1
            } = req.query;

            // Validaci√≥n mejorada
            if (!categorie || !subCategory) {
                return res.status(400).json({
                    success: false,
                    message: 'Se requiere categorie y subCategory'
                });
            }

            // Importar el modelo CORRECTAMENTE


            // Construir query
            let query = {
                categorie: categorie.trim(),
                subCategory: subCategory.trim(),
                isActive: true
            };

            // Excluir post actual
            if (excludeId && mongoose.Types.ObjectId.isValid(excludeId)) {
                query._id = { $ne: new mongoose.Types.ObjectId(excludeId) };
            }

            console.log('üîç Query de b√∫squeda:', query);

            // Paginaci√≥n
            const skip = (parseInt(page) - 1) * parseInt(limit);

            // Buscar posts
            const posts = await Posts.find(query)
                .populate('user', 'name avatar')
                .populate('likes', '_id name')
                .sort({ isPromoted: -1, isUrgent: -1, createdAt: -1 })
                .skip(skip)
                .limit(parseInt(limit));

            const total = await Posts.countDocuments(query);
            const totalPages = Math.ceil(total / parseInt(limit));
            const hasMore = page < totalPages;

            console.log(`‚úÖ Encontrados ${posts.length} posts de ${total}`);

            res.json({
                success: true,
                posts,
                total,
                page: parseInt(page),
                totalPages,
                hasMore
            });

        } catch (error) {
            console.error('‚ùå getSimilarPosts error completo:', error);
            res.status(500).json({
                success: false,
                message: 'Error del servidor',
                error: error.message,
                stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
            });
        }
    },

    getPosts: async (req, res) => {
        try {
            const {
                page = 1,
                limit = 9,
                category,
                subcategory,  // ‚Üê NUEVO PAR√ÅMETRO
                ...filters
            } = req.query;

            const skip = (page - 1) * limit;

            // Construir query base
            let query = { isActive: true };

            // Filtrar por categor√≠a
            if (category && category !== 'all') {
                query.categorie = category;
            }

            // Filtrar por subcategor√≠a (NUEVO)
            if (subcategory && subcategory !== 'all') {
                query.subCategory = subcategory;
            }

            // Aplicar otros filtros del categorySpecificData
            if (filters) {
                Object.entries(filters).forEach(([key, value]) => {
                    if (value && key.startsWith('spec_')) {
                        const field = key.replace('spec_', '');
                        query[`categorySpecificData.${field}`] = value;
                    }
                });
            }

            console.log('üîç Query final:', query);

            // Obtener posts
            const posts = await Posts.find(query)
                .skip(skip)
                .limit(parseInt(limit))
                .sort({ isPromoted: -1, isUrgent: -1, createdAt: -1 })
                .populate("user", "avatar username");

            // Contar total
            const total = await Posts.countDocuments(query);

            res.json({
                success: true,
                result: posts.length,
                total,
                page: parseInt(page),
                totalPages: Math.ceil(total / limit),
                hasMore: skip + posts.length < total,
                posts
            });

        } catch (err) {
            console.error('‚ùå Error en getPosts:', err);
            return res.status(500).json({ msg: err.message });
        }
    },


    updatePost: async (req, res) => {
        try {
            const { postData, images } = req.body;

            // 1. Obtener el post actual
            const oldPost = await Posts.findById(req.params.id);
            if (!oldPost) {
                return res.status(400).json({ msg: "Ce post n'existe pas." });
            }

            // 2. Separar campos base de campos espec√≠ficos
            const commonFields = [
                'categorie', 'subCategory', 'articleType',
                'title', 'description', 'price',
                'wilaya', 'commune', 'numeroTelephone',
            ];

            const updateData = {};
            const specificData = {};

            Object.keys(postData).forEach(key => {
                if (commonFields.includes(key)) {
                    updateData[key] = postData[key];
                } else {
                    specificData[key] = postData[key];
                }
            });

            // 3. A√±adir categorySpecificData al updateData
            if (Object.keys(specificData).length > 0) {
                updateData.categorySpecificData = specificData;
            }

            // 4. A√±adir im√°genes
            updateData.images = images || postData.images;

            console.log('üîÑ Datos para actualizar:', {
                updateData,
                specificDataKeys: Object.keys(specificData)
            });

            // 5. Actualizar en MongoDB
            const post = await Posts.findOneAndUpdate(
                { _id: req.params.id },
                { $set: updateData },
                { new: true, runValidators: true }
            );

            // 6. Populate
            await post.populate('user', 'avatar username');

            res.json({
                msg: 'Post modifi√© avec succ√®s!',
                newPost: post
            });

        } catch (err) {
            console.error('Error en updatePost:', err);
            return res.status(500).json({ msg: err.message });
        }
    },
    deletePost: async (req, res) => {
        try {
            const postId = req.params.id;
            const userId = req.user._id;

            // 1. VERIFICAR SI EL USUARIO ES EL DUE√ëO O ADMIN
            const post = await Posts.findById(postId);

            if (!post) {
                return res.status(404).json({ msg: 'Post not found' });
            }

            if (post.user.toString() !== userId.toString() && req.user.role !== 'admin') {
                return res.status(403).json({ msg: 'Not authorized to delete this post' });
            }

            console.log('üóëÔ∏è Eliminando post y sus im√°genes:', post.images);

            // 2. BORRAR TODAS LAS IM√ÅGENES DEL POST DE CLOUDINARY
            if (post.images && post.images.length > 0) {
                for (const image of post.images) {
                    if (image.public_id) {
                        try {
                            await cloudinary.uploader.destroy(image.public_id);
                            console.log('‚úÖ Imagen borrada de Cloudinary:', image.public_id);
                        } catch (cloudinaryErr) {
                            console.error('‚ùå Error borrando imagen de Cloudinary:', image.public_id, cloudinaryErr);
                            // Continuar aunque falle una imagen
                        }
                    }
                }
            }

            // 3. GUARDAR IDs DE COMMENTS Y LIKES ANTES DE ELIMINAR
            const commentsToDelete = post.comments || [];
            const likesToCleanup = post.likes || [];

            // 4. ELIMINAR EL POST DE MONGODB
            await Posts.findByIdAndDelete(postId);

            // 5. LIMPIAR DATOS RELACIONADOS
            if (commentsToDelete.length > 0) {
                await Comments.deleteMany({ _id: { $in: commentsToDelete } });
            }

            // 6. OPCIONAL: Limpiar likes de usuarios
            if (likesToCleanup.length > 0) {
                await Users.updateMany(
                    { _id: { $in: likesToCleanup } },
                    { $pull: { likes: postId } }
                );
            }

            // 7. OPCIONAL: Eliminar de posts guardados
            await Users.updateMany(
                { saved: postId },
                { $pull: { saved: postId } }
            );

            res.json({
                msg: 'Post deleted successfully!',
                deletedPostId: postId,
                deletedImagesCount: post.images ? post.images.length : 0
            });

        } catch (err) {
            console.error('Error in deletePost:', err);
            return res.status(500).json({ msg: err.message });
        }
    },
    getUserPosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({ user: req.params.id }), req.query)
                .paginating()
            const posts = await features.query.sort("-createdAt")

            res.json({
                posts,
                result: posts.length
            })

        } catch (err) {
            return res.status(500).json({ msg: err.message })
        }
    },
    getPost: async (req, res) => {
        try {
            const post = await Posts.findById(req.params.id)
                .populate("user likes", "avatar username")
                .populate({
                    path: "comments",
                    populate: {
                        path: "user likes",
                        select: "-password"
                    }
                })

            if (!post) return res.status(400).json({ msg: 'This post does not exist.' })

            res.json({
                post
            })

        } catch (err) {
            return res.status(500).json({ msg: err.message })
        }
    },
    getPostsDicover: async (req, res) => {
        try {

            const newArr = [...req.user.following, req.user._id]

            const num = req.query.num || 9

            const posts = await Posts.aggregate([
                { $match: { user: { $nin: newArr } } },
                { $sample: { size: Number(num) } },
            ])

            return res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            })

        } catch (err) {
            return res.status(500).json({ msg: err.message })
        }
    },

    savePost: async (req, res) => {
        try {
            const user = await Users.find({ _id: req.user._id, saved: req.params.id })
            if (user.length > 0) return res.status(400).json({ msg: "You saved this post." })

            const save = await Users.findOneAndUpdate({ _id: req.user._id }, {
                $push: { saved: req.params.id }
            }, { new: true })

            if (!save) return res.status(400).json({ msg: 'This user does not exist.' })

            res.json({ msg: 'Saved Post!' })

        } catch (err) {
            return res.status(500).json({ msg: err.message })
        }
    },
    unSavePost: async (req, res) => {
        try {
            const save = await Users.findOneAndUpdate({ _id: req.user._id }, {
                $pull: { saved: req.params.id }
            }, { new: true })

            if (!save) return res.status(400).json({ msg: 'This user does not exist.' })

            res.json({ msg: 'unSaved Post!' })

        } catch (err) {
            return res.status(500).json({ msg: err.message })
        }
    },
    getSavePosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({
                _id: { $in: req.user.saved }
            }), req.query).paginating()

            const savePosts = await features.query.sort("-createdAt")

            res.json({
                savePosts,
                result: savePosts.length
            })

        } catch (err) {
            return res.status(500).json({ msg: err.message })
        }
    },











// üìå OBTENER BOUTIQUE POR ID
getBoutiqueById: async (req, res) => {
    try {
        const { boutiqueId } = req.params;
        
        const boutique = await Posts.findOne({
            _id: boutiqueId,
            postType: 'boutique'
        }).populate('user', 'avatar username email');
        
        if (!boutique) {
            return res.status(404).json({ 
                success: false, 
                msg: 'Boutique non trouv√©e' 
            });
        }
        
        // Usar verificaci√≥n tradicional en lugar de optional chaining
        const boutiqueData = boutique.boutiqueData || {};
        
        res.json({
            success: true,
            boutique: {
                _id: boutique._id,
                postType: 'boutique',
                title: boutique.title,
                boutique: boutiqueData,
                user: boutique.user,
                images: boutique.images,
                createdAt: boutique.createdAt,
                views: boutique.views || 0
            }
        });
    } catch (err) {
        console.error('‚ùå Error en getBoutiqueById:', err);
        return res.status(500).json({ success: false, msg: err.message });
    }
},

// üìå ACTUALIZAR BOUTIQUE (simple)
updateBoutique: async (req, res) => {
    try {
        const { boutiqueId } = req.params;
        const updateData = req.body;
        
        const boutique = await Posts.findOne({
            _id: boutiqueId,
            postType: 'boutique'
        });
        
        if (!boutique) {
            return res.status(404).json({ 
                success: false, 
                msg: 'Boutique non trouv√©e' 
            });
        }
        
        // Solo el propietario puede actualizar
        if (!boutique.user.equals(req.user._id)) {
            return res.status(403).json({ 
                success: false, 
                msg: 'Acc√®s non autoris√©' 
            });
        }
        
        // Campos permitidos para actualizaci√≥n
        const allowedFields = [
            'slogan_boutique',
            'description_boutique',
            'categories_produits',
            'couleur_theme',
            'reseaux_sociaux',
            'proprietaire_adresse',
            'proprietaire_telephone'
        ];
        
        // Asegurar que boutiqueData existe
        if (!boutique.boutiqueData) {
            boutique.boutiqueData = {};
        }
        
        // Actualizar solo campos permitidos
        allowedFields.forEach(field => {
            if (updateData[field] !== undefined) {
                boutique.boutiqueData[field] = updateData[field];
            }
        });
        
        await boutique.save();
        
        res.json({
            success: true,
            msg: 'Boutique mise √† jour avec succ√®s',
            boutique: {
                _id: boutique._id,
                nom_boutique: boutique.boutiqueData && boutique.boutiqueData.nom_boutique,
                // Usar spread operator con verificaci√≥n
                ...(boutique.boutiqueData || {})
            }
        });
    } catch (err) {
        console.error('‚ùå Error en updateBoutique:', err);
        return res.status(500).json({ success: false, msg: err.message });
    }
},

// üìå SUSPENDER BOUTIQUE (simple)
suspendBoutique: async (req, res) => {
    try {
        const { boutiqueId } = req.params;
        
        const boutique = await Posts.findOne({
            _id: boutiqueId,
            postType: 'boutique'
        });
        
        if (!boutique) {
            return res.status(404).json({ 
                success: false, 
                msg: 'Boutique non trouv√©e' 
            });
        }
        
        // Solo el propietario o admin puede suspender
        const isOwner = boutique.user && boutique.user.equals(req.user._id);
        const isAdmin = req.user && req.user.role === 'admin';
        
        if (!isOwner && !isAdmin) {
            return res.status(403).json({ 
                success: false, 
                msg: 'Acc√®s non autoris√©' 
            });
        }
        
        // Asegurar que boutiqueData existe
        if (!boutique.boutiqueData) {
            boutique.boutiqueData = {};
        }
        
        boutique.boutiqueData.boutique_status = 'suspended';
        boutique.isActive = false;
        
        await boutique.save();
        
        res.json({
            success: true,
            msg: 'Boutique suspendue avec succ√®s',
            boutique: {
                _id: boutique._id,
                nom_boutique: boutique.boutiqueData && boutique.boutiqueData.nom_boutique,
                status: 'suspended'
            }
        });
    } catch (err) {
        console.error('‚ùå Error en suspendBoutique:', err);
        return res.status(500).json({ success: false, msg: err.message });
    }
},

// üìå OBTENER BOUTIQUES ACTIVAS (simple)
getActiveBoutiques: async (req, res) => {
    try {
        const { limit = 8 } = req.query;
        
        const boutiques = await Posts.find({
            postType: 'boutique',
            'boutiqueData.boutique_status': 'active',
            isActive: true
        })
        .limit(parseInt(limit))
        .sort({ isPromoted: -1, createdAt: -1 })
        .populate('user', 'avatar username');
        
        const formattedBoutiques = boutiques.map(b => {
            const boutiqueData = b.boutiqueData || {};
            return {
                _id: b._id,
                nom_boutique: boutiqueData.nom_boutique,
                domaine_boutique: boutiqueData.domaine_boutique,
                slogan_boutique: boutiqueData.slogan_boutique,
                description_boutique: boutiqueData.description_boutique,
                logo_boutique: boutiqueData.logo_boutique,
                user: b.user,
                plan: boutiqueData.plan_boutique,
                date_activation: boutiqueData.date_activation
            };
        });
        
        res.json({
            success: true,
            boutiques: formattedBoutiques
        });
    } catch (err) {
        console.error('‚ùå Error en getActiveBoutiques:', err);
        return res.status(500).json({ success: false, msg: err.message });
    }
},

// üìå BUSCAR BOUTIQUES (simple)
searchBoutiques: async (req, res) => {
    try {
        const { q, page = 1, limit = 10 } = req.query;
        const skip = (page - 1) * limit;
        
        let query = {
            postType: 'boutique',
            'boutiqueData.boutique_status': 'active',
            isActive: true
        };
        
        // B√∫squeda por texto
        if (q) {
            query.$or = [
                { 'boutiqueData.nom_boutique': { $regex: q, $options: 'i' } },
                { 'boutiqueData.description_boutique': { $regex: q, $options: 'i' } },
                { 'boutiqueData.slogan_boutique': { $regex: q, $options: 'i' } }
            ];
        }
        
        const [boutiques, total] = await Promise.all([
            Posts.find(query)
                .skip(skip)
                .limit(parseInt(limit))
                .sort({ isPromoted: -1, createdAt: -1 })
                .populate('user', 'avatar username'),
            Posts.countDocuments(query)
        ]);
        
        res.json({
            success: true,
            boutiques,
            total,
            page: parseInt(page),
            totalPages: Math.ceil(total / parseInt(limit)),
            hasMore: skip + boutiques.length < total
        });
    } catch (err) {
        console.error('‚ùå Error en searchBoutiques:', err);
        return res.status(500).json({ success: false, msg: err.message });
    }
},

// üìå RENOVAR BOUTIQUE
renewBoutique: async (req, res) => {
    try {
        const { boutiqueId } = req.params;
        const { duree_abonnement, plan_boutique } = req.body;
        
        const boutique = await Posts.findOne({
            _id: boutiqueId,
            postType: 'boutique'
        });
        
        if (!boutique) {
            return res.status(404).json({ 
                success: false, 
                msg: 'Boutique non trouv√©e' 
            });
        }
        
        // Solo el propietario puede renovar
        if (!boutique.user.equals(req.user._id)) {
            return res.status(403).json({ 
                success: false, 
                msg: 'Acc√®s non autoris√©' 
            });
        }
        
        // Asegurar que boutiqueData existe
        if (!boutique.boutiqueData) {
            boutique.boutiqueData = {};
        }
        
        // Calcular nueva fecha de expiraci√≥n
        const durationMap = {
            '1_mois': 30,
            '3_mois': 90,
            '6_mois': 180,
            '12_mois': 365
        };
        
        const days = durationMap[duree_abonnement] || 30;
        let newExpiration = new Date();
        
        const currentExpiration = boutique.boutiqueData.date_expiration;
        if (currentExpiration && currentExpiration > new Date()) {
            // Si a√∫n no expir√≥, a√±adir d√≠as a la fecha actual de expiraci√≥n
            newExpiration = new Date(currentExpiration);
            newExpiration.setDate(newExpiration.getDate() + days);
        } else {
            // Si ya expir√≥, empezar desde hoy
            newExpiration.setDate(newExpiration.getDate() + days);
        }
        
        // Actualizar boutique
        boutique.boutiqueData.boutique_status = 'active';
        if (duree_abonnement) {
            boutique.boutiqueData.duree_abonnement = duree_abonnement;
        }
        if (plan_boutique) {
            boutique.boutiqueData.plan_boutique = plan_boutique;
        }
        boutique.boutiqueData.date_expiration = newExpiration;
        boutique.isActive = true;
        
        await boutique.save();
        
        res.json({
            success: true,
            msg: 'Boutique renouvel√©e avec succ√®s',
            boutique: {
                _id: boutique._id,
                nom_boutique: boutique.boutiqueData.nom_boutique,
                status: 'active',
                date_expiration: boutique.boutiqueData.date_expiration,
                plan: boutique.boutiqueData.plan_boutique
            }
        });
    } catch (err) {
        console.error('‚ùå Error en renewBoutique:', err);
        return res.status(500).json({ success: false, msg: err.message });
    }
}





};

module.exports = postCtrl;
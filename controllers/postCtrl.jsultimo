// controllers/postCtrl.js
const mongoose = require('mongoose');
const Posts = require('../models/postModel');
const Comments = require('../models/commentModel');
const Users = require('../models/userModel');
const cloudinary = require('cloudinary').v2;

// Configurar Cloudinary
cloudinary.config({
    cloud_name: 'dfjipgj2o',
    api_key: '213981915435275',
    api_secret: 'wv_IiCM9zzhdiWDNXXo8HZi7wX4'
});

class APIfeatures {
    constructor(query, queryString){
        this.query = query;
        this.queryString = queryString;
    }

    paginating(){
        const page = this.queryString.page * 1 || 1;
        const limit = this.queryString.limit * 1 || 9;
        const skip = (page - 1) * limit;
        this.query = this.query.skip(skip).limit(limit);
        return this;
    }
}

const postCtrl = {
    // üìå CREAR POST
   
   /*
   createPost : async (req, res) => {
        try {
            console.log('üì• Datos recibidos en createPost:', req.body);
           
            
            // ‚úÖ NORMALIZAR CAMPOS DE CATEGOR√çA
            let { 
                categorie, 
                category, 
                subCategory, 
                subcategory,
                subsubcategory,
                articleType,
                categorySpecificData = {},
                ...otherData 
            } = req.body;
            
            // Asegurar nombres consistentes
            const normalizedData = {
                // Usar category si viene, si no categorie
                category: category || categorie || '',
                // Usar subcategory si viene, si no subCategory
                subcategory: subcategory || subCategory || '',
                subsubcategory: subsubcategory || '',
                articleType: articleType || '',
                categorySpecificData: categorySpecificData,
                ...otherData
            };
            
            console.log('üîÑ Datos normalizados:', normalizedData);
            
            // Subir im√°genes a Cloudinary
            const imageUrls = [];
            if (req.files && req.files.length > 0) {
                for (const file of req.files) {
                    const result = await uploadToCloudinary(file);
                    imageUrls.push(result.secure_url);
                }
            }
            
            // Crear post con datos normalizados
            const postData = {
                title: normalizedData.title || '',
                description: normalizedData.description || '',
                price: parseFloat(normalizedData.price) || 0,
                category: normalizedData.category.toLowerCase(),
                subcategory: normalizedData.subcategory.toLowerCase(),
                subsubcategory: normalizedData.subsubcategory.toLowerCase(),
                articleType: normalizedData.articleType || '',
                images: imageUrls,
                postedBy: req.user._id,
                wilaya: normalizedData.wilaya || '',
                commune: normalizedData.commune || '',
                phone: normalizedData.telephone || normalizedData.phone || '',
                email: normalizedData.email || '',
                
                // ‚úÖ GUARDAR categorySpecificData COMO MAP O OBJETO
                categorySpecificData: normalizedData.categorySpecificData || {}
            };
            
            // Agregar campos espec√≠ficos desde categorySpecificData
            if (typeof normalizedData.categorySpecificData === 'object') {
                Object.entries(normalizedData.categorySpecificData).forEach(([key, value]) => {
                    if (value !== undefined && value !== null && value !== '') {
                        postData[key] = value;
                    }
                });
            }
            
            console.log('üì§ Datos para guardar en MongoDB:', {
                category: postData.category,
                subcategory: postData.subcategory,
                subsubcategory: postData.subsubcategory,
                fieldsCount: Object.keys(postData).length
            });
            
            const newPost = new Posts(postData);
            const savedPost = await newPost.save();
            
            console.log('‚úÖ Post guardado en MongoDB:', {
                id: savedPost._id,
                category: savedPost.category,
                subcategory: savedPost.subcategory,
                subsubcategory: savedPost.subsubcategory
            });
            
            res.status(201).json({
                success: true,
                msg: 'Annonce cr√©√©e avec succ√®s',
                post: savedPost
            });
            
        } catch (err) {
            console.error('‚ùå Error en createPost:', err);
            res.status(500).json({
                success: false,
                msg: err.message
            });
        }
    },*/
   
   
   
   
   
    createPost: async (req, res) => {
        try {
            console.log('üì• Datos recibidos en createPost:', req.body);
            
            const { 
                categorie, 
                subCategory, 
                articleType,
                title,
                description,
                price,
                wilaya,
                commune,
                address,
                condition,
                categorySpecificData = {},
                images 
            } = req.body;

            // Validaciones
            if(!images || images.length === 0) {
                return res.status(400).json({msg: "Please add at least one photo."});
            }
            
            if(!categorie) {
                return res.status(400).json({msg: "Category is required."});
            }

            // Preparar datos espec√≠ficos
            const specificDataMap = new Map();
            if (categorySpecificData && typeof categorySpecificData === 'object') {
                Object.entries(categorySpecificData).forEach(([key, value]) => {
                    if (value !== undefined && value !== null && value !== '') {
                        specificDataMap.set(key, value);
                    }
                });
            }

            // Crear nuevo post
            const newPost = new Posts({
                categorie,
                subCategory: subCategory || '',
                articleType: articleType || '',
                title: title || '',
                description: description || '',
                price: price || 0,
                categorySpecificData: specificDataMap,
                images,
                user: req.user._id,
                location: {
                    wilaya: wilaya || '',
                    commune: commune || '',
                    address: address || ''
                },
                condition: condition || 'occasion',
                isActive: true
            });

            await newPost.save();
            
            // Populate para respuesta
            await newPost.populate("user", "avatar username");

            res.json({
                msg: 'Post created successfully!',
                newPost: {
                    ...newPost._doc,
                    user: req.user
                }
            });

        } catch (err) {
            console.error('‚ùå Error en createPost:', err);
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå ACTUALIZAR POST
    updatePost: async (req, res) => {
        try {
            const { postData, images } = req.body;
            
            // 1. Obtener el post actual
            const oldPost = await Posts.findById(req.params.id);
            if (!oldPost) {
                return res.status(400).json({msg: "Ce post n'existe pas."});
            }
            
            // 2. Separar campos base de campos espec√≠ficos
            const commonFields = [
                'categorie', 'subCategory', 'articleType',
                'title', 'description', 'price',
                'wilaya', 'commune', 'numeroTelephone',
            ];
            
            const updateData = {};
            const specificData = {};
            
            Object.keys(postData).forEach(key => {
                if (commonFields.includes(key)) {
                    updateData[key] = postData[key];
                } else {
                    specificData[key] = postData[key];
                }
            });
            
            // 3. A√±adir categorySpecificData al updateData
            if (Object.keys(specificData).length > 0) {
                updateData.categorySpecificData = specificData;
            }
            
            // 4. A√±adir im√°genes
            updateData.images = images || postData.images;
            
            console.log('üîÑ Datos para actualizar:', {
                updateData,
                specificDataKeys: Object.keys(specificData)
            });
            
            // 5. Actualizar en MongoDB
            const post = await Posts.findOneAndUpdate(
                { _id: req.params.id },
                { $set: updateData },
                { new: true, runValidators: true }
            );
            
            // 6. Populate
            await post.populate('user', 'avatar username');
            
            res.json({
                msg: 'Post modifi√© avec succ√®s!',
                newPost: post
            });
            
        } catch (err) {
            console.error('Error en updatePost:', err);
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå ELIMINAR POST
    deletePost: async (req, res) => {
        try {
            const postId = req.params.id;
            const userId = req.user._id;

            // 1. VERIFICAR SI EL USUARIO ES EL DUE√ëO O ADMIN
            const post = await Posts.findById(postId);
            
            if (!post) {
                return res.status(404).json({msg: 'Post not found'});
            }

            if (post.user.toString() !== userId.toString() && req.user.role !== 'admin') {
                return res.status(403).json({msg: 'Not authorized to delete this post'});
            }

            console.log('üóëÔ∏è Eliminando post y sus im√°genes:', post.images);

            // 2. BORRAR TODAS LAS IM√ÅGENES DEL POST DE CLOUDINARY
            if (post.images && post.images.length > 0) {
                for (const image of post.images) {
                    if (image.public_id) {
                        try {
                            await cloudinary.uploader.destroy(image.public_id);
                            console.log('‚úÖ Imagen borrada de Cloudinary:', image.public_id);
                        } catch (cloudinaryErr) {
                            console.error('‚ùå Error borrando imagen de Cloudinary:', image.public_id, cloudinaryErr);
                        }
                    }
                }
            }

            // 3. GUARDAR IDs DE COMMENTS Y LIKES ANTES DE ELIMINAR
            const commentsToDelete = post.comments || [];
            const likesToCleanup = post.likes || [];

            // 4. ELIMINAR EL POST DE MONGODB
            await Posts.findByIdAndDelete(postId);

            // 5. LIMPIAR DATOS RELACIONADOS
            if (commentsToDelete.length > 0) {
                await Comments.deleteMany({_id: {$in: commentsToDelete}});
            }

            // 6. OPCIONAL: Limpiar likes de usuarios
            if (likesToCleanup.length > 0) {
                await Users.updateMany(
                    {_id: {$in: likesToCleanup}},
                    {$pull: {likes: postId}}
                );
            }

            // 7. OPCIONAL: Eliminar de posts guardados
            await Users.updateMany(
                {saved: postId},
                {$pull: {saved: postId}}
            );

            res.json({
                msg: 'Post deleted successfully!',
                deletedPostId: postId,
                deletedImagesCount: post.images ? post.images.length : 0
            });

        } catch (err) {
            console.error('Error in deletePost:', err);
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå OBTENER TODOS LOS POSTS
    getPosts: async (req, res) => {
        try {
            const { 
                page = 1, 
                limit = 9, 
                category, 
                subcategory,
                ...filters 
            } = req.query;
            
            const skip = (page - 1) * limit;
            
            // Construir query base
            let query = { isActive: true };
            
            // Filtrar por categor√≠a
            if (category && category !== 'all') {
                query.categorie = category;
            }
            
            // Filtrar por subcategor√≠a
            if (subcategory && subcategory !== 'all') {
                query.subCategory = subcategory;
            }
            
            // Aplicar otros filtros del categorySpecificData
            if (filters) {
                Object.entries(filters).forEach(([key, value]) => {
                    if (value && key.startsWith('spec_')) {
                        const field = key.replace('spec_', '');
                        query[`categorySpecificData.${field}`] = value;
                    }
                });
            }
            
            console.log('üîç Query final:', query);
            
            // Obtener posts
            const posts = await Posts.find(query)
                .skip(skip)
                .limit(parseInt(limit))
                .sort({ isPromoted: -1, isUrgent: -1, createdAt: -1 })
                .populate("user", "avatar username");
            
            // Contar total
            const total = await Posts.countDocuments(query);
            
            res.json({
                success: true,
                result: posts.length,
                total,
                page: parseInt(page),
                totalPages: Math.ceil(total / limit),
                hasMore: skip + posts.length < total,
                posts
            });

        } catch (err) {
            console.error('‚ùå Error en getPosts:', err);
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå OBTENER POST POR ID
    getPost: async (req, res) => {
        try {
            const post = await Posts.findById(req.params.id)
                .populate("user likes", "avatar username")
                .populate({
                    path: "comments",
                    populate: {
                        path: "user likes",
                        select: "-password"
                    }
                });

            if(!post) return res.status(400).json({msg: 'This post does not exist.'});

            res.json({
                post
            });

        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå OBTENER POSTS SIMILARES
    getSimilarPosts: async (req, res) => {
        try {
            console.log('üì• getSimilarPosts recibi√≥:', req.query);
            
            const { 
                categorie,
                subCategory, 
                excludeId, 
                limit = 6, 
                page = 1 
            } = req.query;
            
            // Validaci√≥n
            if (!categorie || !subCategory) {
                return res.status(400).json({ 
                    success: false,
                    message: 'Se requiere categorie y subCategory' 
                });
            }
    
            // Construir query
            let query = { 
                categorie: categorie.trim(),
                subCategory: subCategory.trim(),
                isActive: true
            };
            
            // Excluir post actual
            if (excludeId && mongoose.Types.ObjectId.isValid(excludeId)) {
                query._id = { $ne: new mongoose.Types.ObjectId(excludeId) };
            }

            console.log('üîç Query de b√∫squeda:', query);
            
            // Paginaci√≥n
            const skip = (parseInt(page) - 1) * parseInt(limit);
            
            // Buscar posts
            const posts = await Posts.find(query)
                .populate('user', 'name avatar')
                .populate('likes', '_id name')
                .sort({ isPromoted: -1, isUrgent: -1, createdAt: -1 })
                .skip(skip)
                .limit(parseInt(limit));
            
            const total = await Posts.countDocuments(query);
            const totalPages = Math.ceil(total / parseInt(limit));
            const hasMore = page < totalPages;

            console.log(`‚úÖ Encontrados ${posts.length} posts de ${total}`);
            
            res.json({
                success: true,
                posts,
                total,
                page: parseInt(page),
                totalPages,
                hasMore
            });
            
        } catch (error) {
            console.error('‚ùå getSimilarPosts error:', error);
            res.status(500).json({ 
                success: false,
                message: 'Error del servidor', 
                error: error.message
            });
        }
    },

    // üìå OBTENER POSTS DE UN USUARIO
    getUserPosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({user: req.params.id}), req.query)
                .paginating();
            const posts = await features.query.sort("-createdAt");

            res.json({
                posts,
                result: posts.length
            });

        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå OBTENER POSTS PARA DESCUBRIR
    getPostsDicover: async (req, res) => {
        try {
            const newArr = [...req.user.following, req.user._id];
            const num = req.query.num || 9;

            const posts = await Posts.aggregate([
                { $match: { user : { $nin: newArr } } },
                { $sample: { size: Number(num) } },
            ]);

            return res.json({
                msg: 'Success!',
                result: posts.length,
                posts
            });

        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå GUARDAR POST
    savePost: async (req, res) => {
        try {
            const user = await Users.find({_id: req.user._id, saved: req.params.id});
            if(user.length > 0) return res.status(400).json({msg: "You saved this post."});

            const save = await Users.findOneAndUpdate({_id: req.user._id}, {
                $push: {saved: req.params.id}
            }, {new: true});

            if(!save) return res.status(400).json({msg: 'This user does not exist.'});

            res.json({msg: 'Saved Post!'});

        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå QUITAR POST GUARDADO
    unSavePost: async (req, res) => {
        try {
            const save = await Users.findOneAndUpdate({_id: req.user._id}, {
                $pull: {saved: req.params.id}
            }, {new: true});

            if(!save) return res.status(400).json({msg: 'This user does not exist.'});

            res.json({msg: 'unSaved Post!'});

        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    },

    // üìå OBTENER POSTS GUARDADOS
    getSavePosts: async (req, res) => {
        try {
            const features = new APIfeatures(Posts.find({
                _id: {$in: req.user.saved}
            }), req.query).paginating();

            const savePosts = await features.query.sort("-createdAt");

            res.json({
                savePosts,
                result: savePosts.length
            });

        } catch (err) {
            return res.status(500).json({msg: err.message});
        }
    }
};

module.exports = postCtrl;
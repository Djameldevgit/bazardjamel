// redux/actions/postCategoryAction.js
import { GLOBALTYPES } from './globalTypes'
import { getDataAPI } from '../../utils/fetchData'

export const POST_CATEGORY_TYPES = {
    // Categor√≠as paginadas
    GET_CATEGORIES_PAGINATED: 'GET_CATEGORIES_PAGINATED',
    LOADING_CATEGORIES: 'LOADING_CATEGORIES',
    
    // Posts por categor√≠a y subcategor√≠a
    GET_POSTS_BY_CATEGORY: 'GET_POSTS_BY_CATEGORY',
    GET_POSTS_BY_SUBCATEGORY: 'GET_POSTS_BY_SUBCATEGORY',
    GET_SUBCATEGORIES: 'GET_SUBCATEGORIES',
    
    // Sistema jer√°rquico
    GET_POSTS_BY_CATEGORY_HIERARCHY: 'GET_POSTS_BY_CATEGORY_HIERARCHY',
    GET_CATEGORIES_HIERARCHY: 'GET_CATEGORIES_HIERARCHY',
    GET_SUBSUBCATEGORIES: 'GET_SUBSUBCATEGORIES',
    
    // Estados de carga
    LOADING_CATEGORY_HIERARCHY: 'LOADING_CATEGORY_HIERARCHY',
    LOADING_SUBSUBCATEGORIES: 'LOADING_SUBSUBCATEGORIES',
    LOADING_SUBCATEGORIES: 'LOADING_SUBCATEGORIES',
    
    // Manejo de niveles
    SET_CURRENT_CATEGORY_LEVEL: 'SET_CURRENT_CATEGORY_LEVEL',
    CLEAR_CATEGORY_HIERARCHY: 'CLEAR_CATEGORY_HIERARCHY',
    
    // Error
    ERROR_CATEGORY: 'ERROR_CATEGORY'
};
// redux/actions/postCategoryAction.js - CORREGIR
export const getPostsByCategory = (category, page = 1, limit = 12) => async (dispatch) => {
    try {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: true });
        
        console.log(`üì° Cargando posts para categor√≠a: ${category}, p√°gina: ${page}, limit: ${limit}`);
        
        // ‚úÖ ASEGURAR que limit sea un n√∫mero
        const safeLimit = parseInt(limit) || 12;
        
        const res = await getDataAPI(`posts/category/${category}?page=${page}&limit=${safeLimit}`);
        
        console.log('üì• Respuesta categor√≠a:', {
            success: res.data.success,
            postsCount: res.data.posts?.length,
            total: res.data.total
        });
        
        dispatch({
            type: POST_CATEGORY_TYPES.GET_POSTS_BY_CATEGORY,
            payload: {
                category,
                posts: res.data.posts || [],
                page: res.data.currentPage || page,
                total: res.data.total || 0,
                totalPages: res.data.pages || Math.ceil((res.data.total || 0) / safeLimit),
                result: res.data.result || res.data.posts?.length || 0
            }
        });
        
        return res.data;
        
    } catch (err) {
        console.error('‚ùå Error en getPostsByCategory:', err);
        
        dispatch({
            type: POST_CATEGORY_TYPES.ERROR_CATEGORY,
            payload: { error: err.response?.data?.msg || 'Error cargando categor√≠a' }
        });
        
        return {
            success: false,
            posts: [],
            total: 0,
            pages: 0,
            currentPage: page
        };
    } finally {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: false });
    }
};

// üìÇ redux/actions/postCategoryAction.js - ACTUALIZAR
export const getPostsByCategoryHierarchy = (level1, level2 = null, level3 = null, page = 1, limit = 12) => async (dispatch) => {
    try {
        // ‚úÖ VERIFICAR SI ES LLAMADA VAC√çA (desde App.js)
        if (!level1 && !level2 && !level3) {
            console.log('üì° Llamada vac√≠a de getPostsByCategoryHierarchy - Ignorando');
            return {
                success: false,
                message: 'No se proporcionaron par√°metros de jerarqu√≠a'
            };
        }
        
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: true });
        
        console.log(`üì° Llamando API jerarqu√≠a: ${level1}${level2 ? '/' + level2 : ''}${level3 ? '/' + level3 : ''} - P√°gina ${page}, Limit: ${limit}`);
        
        // ‚úÖ Validar par√°metros para evitar undefined
        const safeLevel1 = level1 || '';
        const safeLevel2 = level2 && level2 !== 'undefined' && level2 !== 'null' ? level2 : null;
        const safeLevel3 = level3 && level3 !== 'undefined' && level3 !== 'null' ? level3 : null;
        const safeLimit = parseInt(limit) || 12;
        
        // ‚úÖ Construir URL correctamente
        let url = `posts/hierarchy/${safeLevel1}`;
        if (safeLevel2) url += `/${safeLevel2}`;
        if (safeLevel3) url += `/${safeLevel3}`;
        
        // ‚úÖ A√±adir par√°metros de paginaci√≥n
        url += `?page=${page}&limit=${safeLimit}`;
        
        console.log('üåê URL final:', url);
        
        const res = await getDataAPI(url);
        
        console.log('üì• Respuesta API:', {
            success: res.data.success,
            postsCount: res.data.posts?.length,
            total: res.data.total,
            page: res.data.currentPage
        });
        
        const actionPayload = {
            level1: safeLevel1,
            level2: safeLevel2,
            level3: safeLevel3,
            posts: res.data.posts || [],
            page: res.data.currentPage || page,
            total: res.data.total || 0,
            totalPages: res.data.pages || Math.ceil((res.data.total || 0) / safeLimit),
            sublevels: res.data.sublevels || [],
            categoryPath: res.data.categoryPath || 
                         (safeLevel3 ? `${safeLevel1}/${safeLevel2}/${safeLevel3}` : 
                          safeLevel2 ? `${safeLevel1}/${safeLevel2}` : safeLevel1)
        };
        
        dispatch({
            type: POST_CATEGORY_TYPES.GET_POSTS_BY_CATEGORY_HIERARCHY,
            payload: actionPayload
        });
        
        return res.data;
        
    } catch (err) {
        console.error('‚ùå Error en getPostsByCategoryHierarchy:', err);
        
        // ‚úÖ Manejar error espec√≠fico para llamadas vac√≠as
        if (!level1 && !level2 && !level3) {
            console.log('‚ö†Ô∏è Llamada vac√≠a - No dispatch error');
            return {
                success: false,
                posts: [],
                total: 0,
                pages: 0,
                currentPage: page
            };
        }
        
        dispatch({
            type: POST_CATEGORY_TYPES.ERROR_CATEGORY,
            payload: err.response?.data?.msg || err.message || 'Error al cargar los anuncios'
        });
        
        return {
            success: false,
            posts: [],
            total: 0,
            pages: 0,
            currentPage: page,
            error: err.response?.data?.msg || 'Error del servidor'
        };
    } finally {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: false });
    }
};
// üìå OBTENER CATEGOR√çAS PAGINADAS
export const getCategories = (page = 1, limit = 20) => async (dispatch, getState) => {
    try {
        console.log(`üì° Llamando API categor√≠as - P√°gina ${page}, L√≠mite ${limit}`);
        
        const { auth } = getState();
        const token = auth?.token;
        
        const res = await getDataAPI(
            `categories/paginated?page=${page}&limit=${limit}`,
            token
        );
        
        console.log('üì• Respuesta categor√≠as completa:', res.data);
        
        if (!res.data.success) {
            throw new Error(res.data.msg || 'Error al cargar categor√≠as');
        }
        
        // Formatear categor√≠as
        const formattedCategories = (res.data.categories || []).map(cat => ({
            ...cat,
            name: cat.displayName || cat.name || 'Sin nombre',
            category: cat.categorie || cat.name,
            slug: cat.slug || (cat.name ? cat.name.toLowerCase().replace(/\s+/g, '-') : 'sin-nombre'),
            emoji: cat.emoji || 'üìÅ'
        }));
        
        console.log('‚úÖ Categor√≠as formateadas:', formattedCategories);
        
        dispatch({
            type: POST_CATEGORY_TYPES.GET_CATEGORIES_PAGINATED,
            payload: {
                categories: formattedCategories,
                page: res.data.page || page,
                total: res.data.total || 0,
                hasMore: res.data.hasMore || false
            }
        });
        
        return res.data;
        
    } catch (err) {
        console.error('‚ùå Error en getCategories:', err);
        dispatch({
            type: POST_CATEGORY_TYPES.ERROR_CATEGORY,
            payload: err.response?.data?.msg || 'Error cargando categor√≠as'
        });
        throw err;
    }
};

// üìå OBTENER POSTS POR CATEGOR√çA
 

// üìå OBTENER SUBCATEGOR√çAS DE UNA CATEGOR√çA
export const getSubCategoriesByCategory = (categorySlug) => async (dispatch) => {
    try {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_SUBCATEGORIES, payload: true });
        
        console.log(`üì° Buscando subcategor√≠as para: ${categorySlug}`);
        
        const res = await getDataAPI(`categories/${categorySlug}/subcategories`);
        
        console.log('üì• Subcategor√≠as encontradas:', res.data.subcategories?.length);
        
        dispatch({
            type: POST_CATEGORY_TYPES.GET_SUBCATEGORIES,
            payload: {
                categorySlug,
                subcategories: res.data.subcategories || []
            }
        });
        
        return res.data.subcategories || [];
        
    } catch (err) {
        console.error('‚ùå Error en getSubCategoriesByCategory:', err);
        
        dispatch({
            type: GLOBALTYPES.ALERT,
            payload: {
                error: err.response?.data?.msg || 'Error loading subcategories'
            }
        });
        return [];
    } finally {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_SUBCATEGORIES, payload: false });
    }
};

// üìå OBTENER POSTS POR SUBCATEGOR√çA
export const getPostsBySubcategory = (categorySlug, subcategorySlug, page = 1, limit = 12) => async (dispatch) => {
    try {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: true });
        
        console.log(`üì° Cargando posts para: ${categorySlug}/${subcategorySlug}, p√°gina: ${page}`);
        
        const res = await getDataAPI(`posts/category/${categorySlug}/subcategory/${subcategorySlug}?page=${page}&limit=${limit}`);
        
        console.log('üì• Respuesta subcategor√≠a:', {
            success: res.data.success,
            postsCount: res.data.posts?.length
        });
        
        dispatch({
            type: POST_CATEGORY_TYPES.GET_POSTS_BY_SUBCATEGORY,
            payload: {
                categorySlug,
                subcategorySlug,
                posts: res.data.posts || [],
                page: res.data.currentPage || page,
                total: res.data.total || 0,
                totalPages: res.data.pages || Math.ceil((res.data.total || 0) / limit),
                result: res.data.result || res.data.posts?.length || 0
            }
        });
        
        return res.data;
        
    } catch (err) {
        console.error('‚ùå Error en getPostsBySubcategory:', err);
        
        dispatch({
            type: GLOBALTYPES.ALERT,
            payload: {
                error: err.response?.data?.msg || 'Error loading posts'
            }
        });
    } finally {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: false });
    }
};

// üìå OBTENER POSTS POR JERARQU√çA DE CATEGOR√çAS
 
// üìå OBTENER JERARQU√çA COMPLETA DE CATEGOR√çAS
export const getCategoriesHierarchy = () => async (dispatch) => {
    try {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORY_HIERARCHY, payload: true });
        
        console.log('üì° Obteniendo jerarqu√≠a completa de categor√≠as...');
        
        const res = await getDataAPI('categories/hierarchy');
        
        console.log('üì• Jerarqu√≠a recibida:', {
            categoriesCount: res.data.hierarchy?.length
        });
        
        dispatch({
            type: POST_CATEGORY_TYPES.GET_CATEGORIES_HIERARCHY,
            payload: res.data.hierarchy || []
        });
        
        return res.data.hierarchy || [];
        
    } catch (err) {
        console.error('‚ùå Error en getCategoriesHierarchy:', err);
        return [];
    } finally {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORY_HIERARCHY, payload: false });
    }
};

// üìå OBTENER SUB-SUBCATEGOR√çAS (Nivel 3)
export const getSubSubCategories = (category, subcategory) => async (dispatch) => {
    try {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_SUBSUBCATEGORIES, payload: true });
        
        console.log(`üì° Buscando sub-subcategor√≠as: ${category}/${subcategory}`);
        
        const res = await getDataAPI(`categories/${category}/${subcategory}/subsubcategories`);
        
        console.log('üì• Sub-subcategor√≠as encontradas:', {
            count: res.data.subSubCategories?.length
        });
        
        dispatch({
            type: POST_CATEGORY_TYPES.GET_SUBSUBCATEGORIES,
            payload: {
                category,
                subcategory,
                subSubCategories: res.data.subSubCategories || []
            }
        });
        
        return res.data.subSubCategories || [];
        
    } catch (err) {
        console.error('‚ùå Error en getSubSubCategories:', err);
        
        dispatch({
            type: POST_CATEGORY_TYPES.ERROR_CATEGORY,
            payload: err.response?.data?.msg || 'Error cargando sub-categor√≠as'
        });
        
        return [];
    } finally {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_SUBSUBCATEGORIES, payload: false });
    }
};

// üìå ESTABLECER NIVEL ACTUAL DE CATEGOR√çA
export const setCurrentCategoryLevel = (level, category = null, subcategory = null, subsubcategory = null) => ({
    type: POST_CATEGORY_TYPES.SET_CURRENT_CATEGORY_LEVEL,
    payload: { level, category, subcategory, subsubcategory }
});

// üìå LIMPIAR JERARQU√çA DE CATEGOR√çAS
export const clearCategoryHierarchy = () => ({
    type: POST_CATEGORY_TYPES.CLEAR_CATEGORY_HIERARCHY
});

// üìå OBTENER POSTS POR OPERACI√ìN DE INMOBILIARIA (opcional)
export const getPostsByImmobilierOperation = (operationId, page = 1, limit = 12) => async (dispatch) => {
    try {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: true });
        
        console.log(`üì° Buscando posts de inmobiliaria: operaci√≥n ${operationId}`);
        
        const res = await getDataAPI(`posts/immobilier/operation/${operationId}?page=${page}&limit=${limit}`);
        
        dispatch({
            type: 'GET_POSTS_BY_IMMOBILIER_OPERATION',
            payload: {
                operationId,
                posts: res.data.posts || [],
                page: res.data.currentPage || page,
                total: res.data.total || 0
            }
        });
        
        return res.data;
        
    } catch (err) {
        console.error('‚ùå Error en getPostsByImmobilierOperation:', err);
        
        dispatch({
            type: POST_CATEGORY_TYPES.ERROR_CATEGORY,
            payload: { error: err.response?.data?.msg || 'Error cargando posts' }
        });
    } finally {
        dispatch({ type: POST_CATEGORY_TYPES.LOADING_CATEGORIES, payload: false });
    }
};